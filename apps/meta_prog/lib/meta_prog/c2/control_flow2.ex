defmodule MetaProg.C2.ControlFlow2 do
  @moduledoc """
  """

  @doc """
  the built-in if/2 is also a macro. When you call if(...), you’re effectively returning the AST generated by the built-in if macro.

  quote Produces AST

  quote ... end directly constructs and returns the AST for whatever code is inside its block.
  if Is a Macro

  Inside that quoted block, if unquote(expr) do ... end is itself a call to Elixir's built-in if macro, which also expands into AST. But from your macro’s perspective, that if(...) call is just another node in the AST you’re building.
  One Final AST

  At compile time, Elixir will keep expanding macros until it ends up with low-level code (like case exprs, function calls, etc.). You don’t end up with two separate AST trees—just one final (fully expanded) AST that the compiler uses.
  Essentially, any macro inside a quote just contributes to the same overall AST. It’s not “AST nested inside AST”; rather, it’s one tree containing macro calls that get expanded step by step.


  defmacro my_if(expr, r) do
    IO.inspect(expr)
    IO.inspect(r)
  end

  error beacuse elise_if is not a keyword and k
  def control_flow2_demo() do
    ControlFlow2.my_if 1 == 1 do
      "correct"
    else_if
      "incorrect"
    else
      "incorrect"
    else
      "incorrect"
    else
      "incorrect"
    end
  end

  but multiple else are possible and will be passed to macro

  def control_flow2_demo() do
    ControlFlow2.my_if 1 == 1 do
      "correct"
    else
      "incorrect"
    else
      "incorrect"
    else
      "incorrect"
    end
  end


  """

  defmacro my_if(expr, do: if_block), do: if(expr, do: if_block, else: nil)

  defmacro my_if(expr, do: if_block, else: else_block) do
    quote do
      case unquote(expr) do
        x when x in [false, nil] ->
          unquote(else_block)

        _ ->
          unquote(if_block)
      end
    end
  end
end
